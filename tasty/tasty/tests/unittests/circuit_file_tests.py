# -*- coding: utf-8 -*-

import unittest
import os.path
from tasty import state
from tasty.circuit.reader import *
from tasty.circuit import comp22int, int2comp2
from itertools import product

class CircuitTestCase(unittest.TestCase):

    def test_PSSW09_Circuit(self):
        ''' Testing PSSW09 Circuit '''

        c = PSSW09Circuit(os.path.join(state.tasty_root, "circuit/circuits/PSSW09_PracticalSFE/AES_PSSW09.txt"))
        c.check()

        k = 0xfffffffffffffffffffffffffffffff0
        m = 0xffffffffffffffffffffffffffffffff
        res = c.eval((k,m))[0]
        self.assertEqual(res, 0x3e67846d19ffcc6d56641b9a7b7b7c5f)
#        print "%x,%x=>%x" % (m,k,res)

    def test_FairplayMP20_Circuit(self):
        """ Testing BNP08 Circuit """
        c = FairplayMP20Circuit(os.path.join(state.tasty_root, "circuit/circuits/BNP08_FairplayMP2.0/Add4.sfdl.cnv"))
        c.check()
        for x,y in product(xrange(8), repeat=2):
            res = c.eval((x,y))[0]
            self.assertEqual(res, x+y)

        c = FairplayMP20Circuit(os.path.join(state.tasty_root, "circuit/circuits/BNP08_FairplayMP2.0/Millionaires.sfdl.cnv"))
        c.check()
        for x,y,z in product(xrange(8), repeat=3):
            res = c.eval((x,y,z))
            self.assertEqual(res[0], x>z)
            self.assertEqual(res[1], y>x and y>z)
            self.assertEqual(res[2], z>x)

        c = FairplayMP20Circuit(os.path.join(state.tasty_root, "circuit/circuits/BNP08_FairplayMP2.0/Voting.sfdl.cnv"))
        c.check()
        for vals in product(xrange(2), repeat=5):
            res = c.eval(vals)
            one = sum(res)
            zero = 5-one
            if one > zero:
                winner = 1
            else:
                winner = 0
            self.assertEqual(res,[winner for i in xrange(5)])

        c = FairplayMP20Circuit(os.path.join(state.tasty_root, "circuit/circuits/BNP08_FairplayMP2.0/Sample.sfdl.cnv"))
        # For non-negative values the circuit works fine
        for x,y in product(xrange(8), repeat=2):
            res = c.eval((x,y))
            self.assertEqual(res[0], comp22int(x,4)>comp22int(y,4))
        # For negative values the circuit generated by FairplayMP seems to be wrong
        for x,y in product(xrange(16), repeat=2):
            xint = comp22int(x,4)
            yint = comp22int(y,4)
            if (xint > yint) != res[0]:
                state.log.warning("wrong result: %d > %d = %s" % (xint, yint, bool(res[0])))
            
            
    def test_FairplayMP21_Circuit(self):
        """ Testing FairplayMP 2.1 """
        
        # Integer addition
        c = FairplayMP21Circuit(os.path.join(state.tasty_root, "circuit/circuits/BNP08_FairplayMP2.1/Add.sfdl.shdl"))
        c.check()
        for x,y in product(xrange(16), repeat=2):
            res = c.eval((x,y))
            resint=comp22int(res[0],5)
            xint = comp22int(x,4)
            yint = comp22int(y,4)
            self.assertEqual(resint, xint+yint)
            
        # Integer Multiplication
        c = FairplayMP21Circuit(os.path.join(state.tasty_root, "circuit/circuits/BNP08_FairplayMP2.1/Multiplication.sfdl.shdl"))
        c.check()
        for x,y in product(xrange(8), repeat=2):
            res = c.eval((x,y))
            resint = comp22int(res[0],8)
            xint = comp22int(x,4)
            yint = comp22int(y,4)
            self.assertEqual(resint, xint * yint)
        # For negative values the circuit generated by FairplayMP seems to be wrong
        for x,y in product(xrange(16), repeat=2):
            res = c.eval((x,y))
            resint = comp22int(res[0],8)
            xint = comp22int(x,4)
            yint = comp22int(y,4)
            if resint != xint*yint:
                state.log.warning("wrong result: %d < %d = %s" % (xint, yint, bool(res[0])))
    
        # Integer comparison
        c = FairplayMP21Circuit(os.path.join(state.tasty_root, "circuit/circuits/BNP08_FairplayMP2.1/Millionaires.sfdl.shdl"))
        c.check()
        for x,y in product(xrange(16), repeat=2):
            res = c.eval((x,y))
            xint = comp22int(x,4)
            yint = comp22int(y,4)
            # For some values the circuit generated by FairplayMP seems to be wrong
            assert res[0] == res[1]
            if res[0] != (xint > yint):
                state.log.warning("wrong result: %d > %d = %s" % (xint, yint, bool(res[0])))

def suite():
    suite = unittest.TestSuite()
    suite.addTest(CircuitTestCase("test_PSSW09_Circuit"))
    suite.addTest(CircuitTestCase("test_FairplayMP20_Circuit"))
    suite.addTest(CircuitTestCase("test_FairplayMP21_Circuit"))

    return suite

if __name__ == '__main__':
    import tasty.utils
    import logging
    from tasty import state
    state.log.setLevel(logging.WARNING)
    unittest.TextTestRunner(verbosity=2).run(suite())
